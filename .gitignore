/node_modules

# request는 누군가에게 무엇을 달라고 "요청" 하는 것 ex) 홈페이지 줘, 로그인 줘, 프로파일 줘
# 웹사이드에 접속할 때 브라우저가 나를 데려가는게 아님 브라우저가 나를 대신해서 웹사이트를 request하고 페이지를 가져다 주는 거임
# 사용자가 원하는 걸 요청할 때, 사용자가 직접 get request하는 게 아님. 브라우저가 get request를 보내는 거임 
# 유저가 뭔가를 요청하거나, 보내거나, 나에게 무슨 행동을 한다, 그게 request임.
# get request에는 route가 있다 어디로 가는지, 가려하는지 (/) ex) /home /login
# 브라우저가 뭔가를 request하면, 서버는 거기에 응답해준다.

# (middleware handler) 모든 middleware는 handler고, 모든 handler는 middleware다. handler => controller
# next argument는 다음 함수를 호출해준다. 모든 controller가 middleware가 될 수 있다
# handler에는 다수의 handler를 사용할 수 있다.
# middleware는 request에 응답하지 않는다. request를 지속시켜 주는거임 (return 사용시  next()사용 불가)


# middleware를 use하는 게 먼저오고, 그 다음에 URL의 get이 와야 함. 순서가 중요
# express는 모든 걸 위에서 아래 순으로 실행시킴 .javaScript처럼
# middleware를 위에다 두면, 모든  route에 적용되는 거임
# middleware가 next()를 호출하지 않으면 handleProtected나 handleHome같은 다음 함수들은 절대 실행되지 않음.
# middleware는 작업을 다음 함수에게 넘기는 함수임. 응답하는 함수가 아님
# 함수가 next()를 호출하면 그건 middleware 이다. 어떤 함수는 send를 사용하는데, 그러면 그건 middleware가 아님 (연결이 중단 되기 때문에)
# middleware는 왼쪽에서 -----> 오른쪽 순서로 작동함 next()를 실행하면 다음게 실행 됨 ex) app.get("/", logger, handleHome);

# "dependencies" 는 프로젝트에 필요한 것 ex)자동차 연료
# "devDependencies"는 개발자가 개발하는데 필요한 것 ex)자동차 네비게이션

# 서버는 컴퓨터 전체를 listen할 수 없다 그래서 port가 있어야 함 port는 예를들어 컴퓨터의 창문이나 문 같은 거임
# port 4000번을 쓰는 이유는 대부분 비어있기 때문에
# request 를 전달하려면 url을 사용해야 한다.
# 어떤 웹사이트를 가려면 내가 가는게 아니라 웹사이트가 오게 하는 것. 내가 요청을 하면 서버가 나의 브라우저를 보내주는 것.
# *브라우저는 서버에게 페이지를 request하는 거임. arrow function은 return이 내포되어 있음.

# routes를 만들고 controllers를 만든다
# 중요한건 위치임(requset, response) 이름은 상관없음 첫 번째 arguments는 X, 두 번째는 Y여도 상관 x
# controller가 있어야 할 자리에 함수를 넣어주지 않으면 에러가 생김!!**

# 라우터는 컨트롤러와 URL의 관리를 쉽게해준다
# 라우터는 너희가 작업중인 주제를 기반으로 URL을 그룹화해줌
# (clean code) 일단 코드를 작성한다 얼마나 지저분한지는 상관이없다 그 다음에 코드를 정리해라 코드를 작성한 시간만큼, 코드를 정리하는데 시간을 들여야 한다.
# 자바스크립트에서는 모든 파일이 자기만의 세계를 가진다 (새로운 파일마다 express import 해줘야한다)
# 모든 파일은 모듈이고, 거품과도 같다 프로젝트에 있는 모든 파일은 분리된 모듈이다 그래서 무언가를 바깥에 공유하기 위해서는 익스포트(export)를 먼저 해줘야함
# 먼저 export 하고 import 해야함
# import (express) from "express"; express 이름이 달라도 된다 하지만 대부분 헷갈려서 같은 이름을 유지함

# globalRouter는 controller가 필요가 없다 다만 url을 깔끔하게 하기위해 쓰는것일 뿐 다른 이유는 없음
# 파일은 한가지 default export 밖에 가질 수 없다 그렇기 때문에 이름이 달라도 가능했음 But export const 를 하면 실제 변수명이 같아야함
# 자바스크립트에선 변수명으로 사용 불가하는게 몇가지 있음 ex)new, delete..
# 라우터는 url이 어떻게 시작하는지에 따라 나누는 방법이다 url을 그룹화하는 방법임 **라우터는 공통 시작부분을 기반으로 url을 정리해주는 방법이다
# ****우리는 변수를 다른 파일에서 가져와 무언가를 임포트하기 전에는 익스포트를 해야한다.**** export default를 쓰면 한가지 밖에 공유가 불가능하다. 
# 그래서 각각의 함수에 export를 달아줘야 함 이렇게 하면 하나 이상을 공유할 수 있음 그리고 쓰는 법이 약간 다름 import {"same name"} form "/경로" 괄호안에는 같은 이름을 써야 함
# 같은 이름을 쓰지 않으면 node.js는 길을 잃음

# ("/:주소") :을 표시하는 이유는 express한테 이게 변수라는 것을 알려주기 위해서임
# express는 이 url이 변수를 가지고 있다는걸 이해함 그리고 express는 우리가 고른 이름과 함께 값을 제공해줌
# 리퀘스느 오브젝트는 리퀘스트에 대한 정보를 담고 있음
# :가 꼭 필요함 없으면 그냥 텍스트임 express는 순서대로 체크하고, upload가 있으면 거기로 데려가 줌
# 정규식: 문자열로부터 특정 정보를 추출해내는 방법

####### 5 ######
# 5.0) node.js 안에 HTML을 다 쓰기에는 너무 길다 말이 안됨 시간아끼기 위해서 pug를 써야함

# 5.1) 
#      1.pug를 설지한다 
#      2.view engine을 pug로 설정해야 한다 app.set("view engine", "pug");
#      3.실제로 pug 파일을 생성한다
# pug를 보내는 과정 pug가 home.pug 파일을 렌더링해서 평범한 html로 변환해줌
# home.pug 파일을 그대로 유저에게 보내는게 아님
# home.pug를 우선 pug에게 보내고 pug가 랜더링해서 평범한 html로 변환해줌
# 그래서 유저는 home.pug를 보는일이 없고 우리가 pug로 파일을 보내면, pug가 이 평범한 html로 변환해줌
# 기본적으로 express는 cwd + /views에서 pug 파일을 찾는다
# cwd 루트 파일은 서버를 기동하는 파일의 위치에 따라 결정된다
# doucuments/wetube 폴더에서 package.json이 node.js를 실행하고 있음 우리가 wetube 안에 있는 package.json에서 node.js를 실행하고 있기 때문에 이 디렉토리가 현재 작업 디렉토리가 되는거임
# 현재 작업 디렉토리는 node.js를 실행하는 디렉토리임

# 5.2) 
# default 값을 process.cwd() + "/src/views" (현재 작업 디렉토리 + "/views/src"로 바꿔야함
# pug의 최고 장점은 반복할 필요가 없다
# 첫째로 파일명은 띄어쓰기가 있으면 안됨 둘째 대문자가 있어도 안됨
# 자바스크립트 코드는 유저가 보기전에 평범한 텍스트로 변환 됨 이것이 바로 렌더링
# partials 최고의 강점 include 파일 경로 해주면 반복작업 필요없음

# 5.3) 
# 블록이란 템플릿의 창문같은 것 무언가를 집어 넣을 수 있는 곳
# extends(확장), inheritance(상속)은 대단함

# 5.4) 
# extend는 html의 베이스를 가질 수 있게 해주기 때문에 좋다
# 블록은 확장한 템플릿 안에 내용을 넣을 수 있는 창문 또는 문 같은것
# 블록 이름은 항상 같아야 함
# 우리는 home.pug를 렌더링하는데 base.pug를 확장하고 base.pug는 우리가 직접 채우는 content 블록을 가지고 있고 그리고 base.pug는 pageTitle을 가지고 있다 그게 우리가 제공해야하는 변수임
# 변수를 제공하는 방법은 render에 파일명을 쓰고 변수를 쓰는거다 컨트롤러에서 변수를 제공

# 5.5) 
# pug는 지저분한 html을 쓰지 않고, 파이썬처럼 깔끔한 코드를 쓸 수 있다.
# pug는 띄어쓰기 탭으로 구분이 가능하다
# block은 확장한 파일과 커뮤니케이션 할 수 있게 해준다

# 5.6) 
# MVP.css 는 html태그들을 살짝 꾸며주는 역할 (https://andybrewer.github.io/mvp/) 사이트 임시방편으로 사용 css는 나중에 하기 때문에

# 5.7) 
# h1 pageTitle을 쓰면 그냥 text인데 h1=pageTitle을 쓰면 variable로 넘어가게 된다 variable이랑 뒤에 text랑 같이쓰려면 ex) ${pageTitle} aa
# condition if, if else 비슷한 문장임

# 5.8) 
# Iteration은 기본적으로 elements의 list를 보여주는 거임
# list를 보여주려면 첫째로, template에는 array인 variable이 있어야 함 array가 없으면 동작하지 않음
# controller에서의 이름이랑 다른 pugpage랑 변수명이 같아야 한다
# Pug는 자동적으로 videos 안에 뭐가 있는지 없는지 체크한다
# 굳이 array이어야만 할 필요는 없고, array이거나 객체도 가능 each else

# 5.9) 
# mixin이란, partials와 같은 것 데이터를 받을 수 있는 일종의 미리 만들어진 HTML block이라고 볼 수 있다
# mixin은 똑똑한 partials이다

# 5.10) 
# Iteration은 array의 모든 element에 대해 특정 행동을 취할 때 사용함
# each X in Y에서 Y는 반드시 존재해야 한다
# each in else 같은 문법은 javascript에 없다 pug에만 있는 문법임
# pug는 똑똑해서 Y가 빈 array 이거나 length가 0이면 바로 알아차려서 else를 보여준다
# mixin은, 이미 만들어진 HTML 조각과 같은데 바깥 세계로부터 정보를 가져오는 역할을 한다.
# mixin을 사용하고 싶다면 +를 붙여햐 함

####### 6 ######
# 6.0)
# {} 이 기호를 쓰는 방식은 attribute에는 사용할 수 없다 href, calss나 id 같은 것들에 가능하지 않음
# 그래서 + 하기 방식이나 ``백틱을 사용해야 한다.

# 6.1) 
# absoulte 와 relative url의 차이점 만약 href의 앞부분에 /를 넣으면 어디에 있든 상관없이 root 경로 + /edit으로 가게 된다.
# 근데 /을 지우면? 이건 relative url이 된다

# 6.2)

# 6.3) 
# 만약 get method를 사용하면, 그 form에 있는 정보가 url에 들어가기 된다
# 너의 database를 변경할 data로 뭔가를 하는가? 뭔가를 수정하거나 추거하거나 삭제하거나 하는 경우 post를 써야한다
# 만약 그냥 데이터를 받는 게 목적이라면, get을 사용하면 된다.
# POST 도 GET 이랑 구조가 같다 URL이 있고 function이 있다
# videoRouter.route("/:id(\\d+)/edit").get(getEdit).post(postEdit); 하나는 get request를 위한 것 하나는 post request를 위한 것 줄여 쓸 수 있다.
# req.params는 우리에게 주어지는 정보
# routes를 사용하기 전에 이 middleware를 사용해야 한다 middleware가 그 form을 이해하고, 그것들은 자바스크립트로 변형시켜줘서 우리가 사용할 수 있게 만드는 것.
# 그걸 위해서 middleware를 route를 사용하기 전에 사용해야 한다.
# app.use(express.urlencoded({ extended: true })); express application이 form의 value들을 이해할 수 있도록 하고 멋진 자바스크립트 형식으로 변형시킨다.

# 6.4) 
# get과 post를 따로 쓰는 대신에, 하나의 경로만 필요로 하는 route를 사용함 그러면 get request와 post request 둘 다 다뤄줌
# 보통 2개 이상의 method를 사용하는 게 아니면, route는 사용하지 않음
# req.body 는 form에 있는 value의 javascript representation이다.
# 그치만 이건 우리가 아주 훌륭한 middleware를 설정해야만 가능한 일이다.
# 바로 urlencoded가 HTML form을 이해하고 그 form을 우리가 사용할 수 있는 javascript object 형식으로 통역해준다.
# middleware가 videoRouter 전에 오기 때문에 어떤 request가 videoRouter.post에 이르렀을 때, req.body가 이미 준비되어 있음. (중요)
# form을 javascript으로 바꿔주는 midleware가 route 전에 있기 때문이다 그 postEdit을 가지고 있는 videoRouter 전에 있다..코드는 위에서 부터 아래로 읽기 때문에
# input 안에 name 넣는 걸 까먹으면 req.body에서 데이터를 볼 수 없다
# mongoose를 통해서, 자바스크립트에서 mongodb와 상호작용을 할거다

# 6.5) 
# 정리
# 우선 controller를 만든 다음에 router를 만들어준다

# 6.6) 
# 버튼을 눌렀을 때 홈페이지를 render한게 아니라 url만 바꾼것임
# input에서 data를 얻을 수 있는 방법은? req.body에서 유저가 input에 작성한 data를 얻을 수 있다.
# 모든 input은 이름이 있어야 한다!

# 6.7) 
# mongodb가 훌륭한 이유는 document-based(문서 기반) 이라는 점이다 일반적으로, database는 document-based가 아니다 보통 sql-based이다 행 기반 엑셀같은
# database도 object로 생각한다 (mongodb)에 저장한 것들은 JSON-like-document임. 그러므로 행으로 된 데이터를 저장할 필요가 없다
# 윈도우는 chocolaty.org 를 사용해서 다운받는게 편하다

# 6.8) 
# mongoose란 node.js와 mongoDB를 이어주는 다리
# jjavascript를 적으면, mongoose.가 mongoDB에게 전해 준다
# 'sudo service mongodb start' 실행 방법

# 6.9) CRUD (Creat, Read, Update, Delete) 라고 한다 

# 6.10) 
# 우선 video의 형태를 정의해 줘야 한다 예) title은 string형식 이다 데이터의 형식을 정의해주고
# 그 다음에 model을 만든다 데이터의 형태인 schema로 구성하면 된다
# 그 다음 해당 model 을 default로 export 해주면 된다
# server.js에 database 를 import해서 연결시킨 후 해당 연결이 성공적일 때, video를 import 해주는 것
# 이것으로 db는 우리 video model을 인지하게 된다
# db를 mongoose와 연결시켜서 video model을 인식시키는 것임

# 6.11)
# 관련된 부분들에 따라 분리시키고 있음 
# 그 이유는 server.js 는 express 된 것들과 server 의 configuration 에 관련된 코드만 처리하기 위해 만들어졌지
# database 나 models 같은 것들을 import 를 하기 위함은 아니여서
# callback 이란 무언가가 발생하고 난 다음 호출되는 function 을 말한다
# callback은 특별한게 아니라 javascript 에서 기다림을 표현하는 하나의 방법이라 생각하면 편함
# database 는 javascript 바깥에 존재한다. 그래서 데이터 전송까지 시간이 걸려 약간의 기다림이 필요하다
# 기다림에는 2가지 방식이 있다 callback promise 
# {} 중괄호는 search terms 를 나타낸다 search terms 가 비어있으면 모든 형식을 찾는다는 것을 뜻 함
# callback 은 err 와 docs 라는 signature 를 가짐

# 6.12)
# callback 의 사용법

####callback####
# Video.find({}, (error, videos) => {});
#   Video.find({}, (error, videos) => {
#    if(error){
#     return res.render("server-error")
#    }
#    return res.render("home", {pageTitle: "Home", vudeos})
#  });
# callback 세계관에선 start, finished 다음에 videos 를 출력해준다


# 6.13)
# promise 는 callback 의 최신 버전이라 생각하면 편함
# callback 이랑 차이점은, await 을 find 앞에 적으면 find는 내가 callback 을 필요로 하지 않는다는 걸 알게 됨

####promise####
# export const home = async (req, res) => {
#  try {
#     console.log("start");
#     const videos = await Video.find({});
#     console.log(videos);
#     console.log("finished");
#     return res.render("home", { pageTitle: "Home", videos });
#   } catch {
#     return res.render("server-error");
#   }
# };
# await 이 대단한 이유는 database 를 기다려주기 때문이다
# javascript 는 기다려주는 기능이 없었다 await 이 나오기 전까지는
# acync 와 await 의 최대 장점은 직관적이라는 것 javascript 가 어디서 어떻게 기다리는지 바로 알 수 있기 때문이다
# promise 세계관에서는 위에서부터 아래로 순서대로 
# 코딩 규칙상 await 는 function 안에서만 사용이 가능한데 해당 function 이 asynchronous 일 때만 가능하다 그렇기에 asyn를 적어주는 것
# 코드 실행 중 어떤 에러가 발생하든 javascript 는 await 내 출력 값을 출력 안하고 아래 에러 출력 코드를 실행시킨다

# 6.14)
# function 안에 return은 그냥 function을 마무리 할 뿐이다
# 무엇을 return 하는 것이 중요한게 아니라 어떤 function 을 호출하는지가 더 중요하다
# return 이 아니라 실행되는 function 들에 집중해야 한다
# render 한 것은 다시 render 할 수 없음 - redirect(), sendStatus(), end() 등등 포함 (express에서 오류 발생)
# return 은 아무것도 안하는데 존재하는 이유 function 을 종료시켜 주는 기능을 하기때문에
# return 을 적어서 실수를 방지하는 것이 좋다

# 6.15)
# form 에는 URL 이란 action 이 있다 이 부분을 삭제하면 HTML 은 이 URL 또는 form 이 부여해주는 주소로 간다는 말
# document 는 데이터를 가진 비디오라 생각하면 편함 그리고 document 를 database 에 저장해야 함
# schema 와 같은 모양으로 document 를 만듦 차이점이 있다면 document 는 실제로 데이터를 담음
# split 은 string 들을 분리 하는 기능을 가지고 있다 splitter 또는 separator 가 그 분리의 기준이 된다
# object 는 document 처럼 ID 가 있어야 한다 고유식별번호가 꼭 필요하다 우리가 다하면 재미가 없으니까 시스템이 랜덤한 id 를 부여해준다.
# 첫 video 를 만든게 맞다 그치만 안나오는 이유는 이 object 는 Javascript 세계에서는 존재하지만 아직 저장이 안 된 상태

# 6.16)
# number 데이터를 넣어도 문제없이 string 으로 변환된다
# 잘못된 정보를 기록하면 올바른 정보가 아니라 document 데이터에 포함되지 않는다
# mongoose 가 데이터 타입의 유효성 검사를 도와주고 있다.(데이터 형태를 미리 정해뒀을 때 얻는 장점 중 하나)
# video.save 를 실행하지만 await 해야함 그 이유는 데이터를 database 에 전송하는데 시간이 걸리기 때문이다 그렇기 때문에 무조건 기다려야 함
# 그리고 video.save 는 생성된 video 를 return 해준다 그리고 그 video 는 database 에 속한 video 이다.
# video.find 는 우리의 video 들을 불러준다
# 진짜 라는 의미는 database 상 존재 한다는 말임
# collections 이란 document 들의 묶음이라 생각
# 어떤 것이든 하는 방법은 두 가지 이상이다
# 하나는 Javascript object 를 만들고 object 를 database 에 저장하는 것
# 두번째는 video.create 방금 작성한 코드와 기능은 똑같은데 Javascript object 를 만들어주는 과정을 우리가 안해도 된다
# 제일 중요 ***mongoose 는 우리를 멍청함에서 구해준다...***

# 6.17)
# 'await' 되는 코드에 오류가 있다면 Javascript 는 더 이상 코드를 실행시키지 않은것이다
# catch 가 없으면 아무것도 실행을 안시킬 것이다

# 6.18)
# 데이터에 대한 구체적인 설정은 정말 정말 중요하다****
# maxlength 를 form 에서도 할 수 있는데 왜 database 에서도 해야 하나? (둘 다 해야함)
# 사용자를 위한 것인데 만약 누가 홈페이지를 해킹 했을 때 HTML 에 들어가서 코드를 삭제 할 수 있기 때문에
# 이렇게 하면 최대, 최소 글자 수 변형을 이용한 비정상적인 업로드는 할 수가 없게 되는 것이다.

# 6.19)
# hexadecimal string(16진수) 0~9 까지의 숫자와 6개의 기로호 이루어진 string
# regular expressions 는 개발자들에게 매우 유용하다
# findOne 은 내가 보내는 모든 condition 을 적용시켜준다
# findById 은  id 로 영상을 찾아낼 수 있는 기능을 지원해준다
# req.param 은 router 가 주는 express 의 기능이다

# 6.20)
# exec Mongoose 내부적으로 만약 내가 excute 를 호출하면 promise 가 return 될 거다
# if 안에 return 이 없으면 Javascript 는 영상이 없을 때 if 안의 코드를 실행하고
# array 를 string 오 format 하는 방법 join() function 을 사용한다

# 6.21)
# 복습 new Video() => video.create() => video.update()
# 고생을 해 봐야 지름길의 고마움을 안다

# 6.22)
# findByIdAndUpdate() 2개의 argument 가 필요하다 하나는 업데이트 하고자 하는 영상의 ID, 두 번째 인수는 업데이트 할 정보 혹은 내용
# 대문자 V 의 Video는 우리가 만든 영상 Model 이고 소문자 v 의 video 는 데이터베이스에서 검색한 영상 object고. 아주다르다
# exist() 같은 경우엔 ID만 받지 않는다. filter 를 받는다
# mongoose에도 middleware 가 있다
# exist()는 필터를 필요로 하고 영상의 어떤 property도 필터 가능하다 하지만 findByid 는 꼭 id 를 인자(argument)로 받는다

# 6.23)
# Mongoose에서 middleware라는 건 document 에 무슨 일이 생기기 전이나 후에 middleware를 적용할 수 있다.
# middleware는 무조건 model 이 생성되기 전에 만들어야 한다

# 6.24)
# statics

# 6.25)
# findByIdAndDelete이용하여 비디오 삭제