/node_modules

# request는 누군가에게 무엇을 달라고 "요청" 하는 것 ex) 홈페이지 줘, 로그인 줘, 프로파일 줘
# 웹사이드에 접속할 때 브라우저가 나를 데려가는게 아님 브라우저가 나를 대신해서 웹사이트를 request하고 페이지를 가져다 주는 거임
# 사용자가 원하는 걸 요청할 때, 사용자가 직접 get request하는 게 아님. 브라우저가 get request를 보내는 거임 
# 유저가 뭔가를 요청하거나, 보내거나, 나에게 무슨 행동을 한다, 그게 request임.
# get request에는 route가 있다 어디로 가는지, 가려하는지 (/) ex) /home /login
# 브라우저가 뭔가를 request하면, 서버는 거기에 응답해준다.

# (middleware handler) 모든 middleware는 handler고, 모든 handler는 middleware다. handler => controller
# next argument는 다음 함수를 호출해준다. 모든 controller가 middleware가 될 수 있다
# handler에는 다수의 handler를 사용할 수 있다.
# middleware는 request에 응답하지 않는다. request를 지속시켜 주는거임 (return 사용시  next()사용 불가)


# middleware를 use하는 게 먼저오고, 그 다음에 URL의 get이 와야 함. 순서가 중요
# express는 모든 걸 위에서 아래 순으로 실행시킴 .javaScript처럼
# middleware를 위에다 두면, 모든  route에 적용되는 거임
# middleware가 next()를 호출하지 않으면 handleProtected나 handleHome같은 다음 함수들은 절대 실행되지 않음.
# middleware는 작업을 다음 함수에게 넘기는 함수임. 응답하는 함수가 아님
# 함수가 next()를 호출하면 그건 middleware 이다. 어떤 함수는 send를 사용하는데, 그러면 그건 middleware가 아님 (연결이 중단 되기 때문에)
# middleware는 왼쪽에서 -----> 오른쪽 순서로 작동함 next()를 실행하면 다음게 실행 됨 ex) app.get("/", logger, handleHome);

# "dependencies" 는 프로젝트에 필요한 것 ex)자동차 연료
# "devDependencies"는 개발자가 개발하는데 필요한 것 ex)자동차 네비게이션

# 서버는 컴퓨터 전체를 listen할 수 없다 그래서 port가 있어야 함 port는 예를들어 컴퓨터의 창문이나 문 같은 거임
# port 4000번을 쓰는 이유는 대부분 비어있기 때문에
# request 를 전달하려면 url을 사용해야 한다.
# 어떤 웹사이트를 가려면 내가 가는게 아니라 웹사이트가 오게 하는 것. 내가 요청을 하면 서버가 나의 브라우저를 보내주는 것.
# *브라우저는 서버에게 페이지를 request하는 거임. arrow function은 return이 내포되어 있음.

# routes를 만들고 controllers를 만든다
# 중요한건 위치임(requset, response) 이름은 상관없음 첫 번째 arguments는 X, 두 번째는 Y여도 상관 x
# controller가 있어야 할 자리에 함수를 넣어주지 않으면 에러가 생김!!**

# 라우터는 컨트롤러와 URL의 관리를 쉽게해준다
# 라우터는 너희가 작업중인 주제를 기반으로 URL을 그룹화해줌
# (clean code) 일단 코드를 작성한다 얼마나 지저분한지는 상관이없다 그 다음에 코드를 정리해라 코드를 작성한 시간만큼, 코드를 정리하는데 시간을 들여야 한다.
# 자바스크립트에서는 모든 파일이 자기만의 세계를 가진다 (새로운 파일마다 express import 해줘야한다)
# 모든 파일은 모듈이고, 거품과도 같다 프로젝트에 있는 모든 파일은 분리된 모듈이다 그래서 무언가를 바깥에 공유하기 위해서는 익스포트(export)를 먼저 해줘야함
# 먼저 export 하고 import 해야함
# import (express) from "express"; express 이름이 달라도 된다 하지만 대부분 헷갈려서 같은 이름을 유지함

# globalRouter는 controller가 필요가 없다 다만 url을 깔끔하게 하기위해 쓰는것일 뿐 다른 이유는 없음
# 파일은 한가지 default export 밖에 가질 수 없다 그렇기 때문에 이름이 달라도 가능했음 But export const 를 하면 실제 변수명이 같아야함
# 자바스크립트에선 변수명으로 사용 불가하는게 몇가지 있음 ex)new, delete..
# 라우터는 url이 어떻게 시작하는지에 따라 나누는 방법이다 url을 그룹화하는 방법임 **라우터는 공통 시작부분을 기반으로 url을 정리해주는 방법이다
# ****우리는 변수를 다른 파일에서 가져와 무언가를 임포트하기 전에는 익스포트를 해야한다.**** export default를 쓰면 한가지 밖에 공유가 불가능하다. 
# 그래서 각각의 함수에 export를 달아줘야 함 이렇게 하면 하나 이상을 공유할 수 있음 그리고 쓰는 법이 약간 다름 import {"same name"} form "/경로" 괄호안에는 같은 이름을 써야 함
# 같은 이름을 쓰지 않으면 node.js는 길을 잃음

# ("/:주소") :을 표시하는 이유는 express한테 이게 변수라는 것을 알려주기 위해서임
# express는 이 url이 변수를 가지고 있다는걸 이해함 그리고 express는 우리가 고른 이름과 함께 값을 제공해줌
# 리퀘스느 오브젝트는 리퀘스트에 대한 정보를 담고 있음
# :가 꼭 필요함 없으면 그냥 텍스트임 express는 순서대로 체크하고, upload가 있으면 거기로 데려가 줌
# 정규식: 문자열로부터 특정 정보를 추출해내는 방법

####### 5 ######
# 5.0) node.js 안에 HTML을 다 쓰기에는 너무 길다 말이 안됨 시간아끼기 위해서 pug를 써야함

# 5.1) 1.pug를 설지한다 
#      2.view engine을 pug로 설정해야 한다 app.set("view engine", "pug");
#      3.실제로 pug 파일을 생성한다
# pug를 보내는 과정 pug가 home.pug 파일을 렌더링해서 평범한 html로 변환해줌
# home.pug 파일을 그대로 유저에게 보내는게 아님
# home.pug를 우선 pug에게 보내고 pug가 랜더링해서 평범한 html로 변환해줌
# 그래서 유저는 home.pug를 보는일이 없고 우리가 pug로 파일을 보내면, pug가 이 평범한 html로 변환해줌
# 기본적으로 express는 cwd + /views에서 pug 파일을 찾는다
# cwd 루트 파일은 서버를 기동하는 파일의 위치에 따라 결정된다
# doucuments/wetube 폴더에서 package.json이 node.js를 실행하고 있음 우리가 wetube 안에 있는 package.json에서 node.js를 실행하고 있기 때문에 이 디렉토리가 현재 작업 디렉토리가 되는거임
# 현재 작업 디렉토리는 node.js를 실행하는 디렉토리임

# 5.2) default 값을 process.cwd() + "/src/views" (현재 작업 디렉토리 + "/views/src"로 바꿔야함
# pug의 최고 장점은 반복할 필요가 없다
# 첫째로 파일명은 띄어쓰기가 있으면 안됨 둘째 대문자가 있어도 안됨
# 자바스크립트 코드는 유저가 보기전에 평범한 텍스트로 변환 됨 이것이 바로 렌더링
# partials 최고의 강점 include 파일 경로 해주면 반복작업 필요없음

# 5.3) 블록이란 템플릿의 창문같은 것 무언가를 집어 넣을 수 있는 곳
# extends(확장), inheritance(상속)은 대단함

# 5.4) extend는 html의 베이스를 가질 수 있게 해주기 때문에 좋다
# 블록은 확장한 템플릿 안에 내용을 넣을 수 있는 창문 또는 문 같은것
# 블록 이름은 항상 같아야 함
# 우리는 home.pug를 렌더링하는데 base.pug를 확장하고 base.pug는 우리가 직접 채우는 content 블록을 가지고 있고 그리고 base.pug는 pageTitle을 가지고 있다 그게 우리가 제공해야하는 변수임
# 변수를 제공하는 방법은 render에 파일명을 쓰고 변수를 쓰는거다 컨트롤러에서 변수를 제공

# 5.5) pug는 지저분한 html을 쓰지 않고, 파이썬처럼 깔끔한 코드를 쓸 수 있다.
# pug는 띄어쓰기 탭으로 구분이 가능하다
# block은 확장한 파일과 커뮤니케이션 할 수 있게 해준다

# 5.6) MVP.css 는 html태그들을 살짝 꾸며주는 역할 (https://andybrewer.github.io/mvp/) 사이트 임시방편으로 사용 css는 나중에 하기 때문에

# 5.7) h1 pageTitle을 쓰면 그냥 text인데 h1=pageTitle을 쓰면 variable로 넘어가게 된다 variable이랑 뒤에 text랑 같이쓰려면 ex) ${pageTitle} aa
# condition if, if else 비슷한 문장임

# 5.8) Iteration은 기본적으로 elements의 list를 보여주는 거임
# list를 보여주려면 첫째로, template에는 array인 variable이 있어야 함 array가 없으면 동작하지 않음
# controller에서의 이름이랑 다른 pugpage랑 변수명이 같아야 한다
# Pug는 자동적으로 videos 안에 뭐가 있는지 없는지 체크한다
# 굳이 array이어야만 할 필요는 없고, array이거나 객체도 가능 each else

# 5.9) mixin이란, partials와 같은 것 데이터를 받을 수 있는 일종의 미리 만들어진 HTML block이라고 볼 수 있다
# mixin은 똑똑한 partials이다

# 5.10) Iteration은 array의 모든 element에 대해 특정 행동을 취할 때 사용함