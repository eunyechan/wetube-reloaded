/node_modules

# request는 누군가에게 무엇을 달라고 "요청" 하는 것 ex) 홈페이지 줘, 로그인 줘, 프로파일 줘
# 웹사이드에 접속할 때 브라우저가 나를 데려가는게 아님 브라우저가 나를 대신해서 웹사이트를 request하고 페이지를 가져다 주는 거임
# 사용자가 원하는 걸 요청할 때, 사용자가 직접 get request하는 게 아님. 브라우저가 get request를 보내는 거임 
# 유저가 뭔가를 요청하거나, 보내거나, 나에게 무슨 행동을 한다, 그게 request임.
# get request에는 route가 있다 어디로 가는지, 가려하는지 (/) ex) /home /login
# 브라우저가 뭔가를 request하면, 서버는 거기에 응답해준다.

# (middleware handler) 모든 middleware는 handler고, 모든 handler는 middleware다. handler => controller
# next argument는 다음 함수를 호출해준다. 모든 controller가 middleware가 될 수 있다
# handler에는 다수의 handler를 사용할 수 있다.
# middleware는 request에 응답하지 않는다. request를 지속시켜 주는거임 (return 사용시  next()사용 불가)


# middleware를 use하는 게 먼저오고, 그 다음에 URL의 get이 와야 함. 순서가 중요
# express는 모든 걸 위에서 아래 순으로 실행시킴 .javaScript처럼
# middleware를 위에다 두면, 모든  route에 적용되는 거임
# middleware가 next()를 호출하지 않으면 handleProtected나 handleHome같은 다음 함수들은 절대 실행되지 않음.
# middleware는 작업을 다음 함수에게 넘기는 함수임. 응답하는 함수가 아님
# 함수가 next()를 호출하면 그건 middleware 이다. 어떤 함수는 send를 사용하는데, 그러면 그건 middleware가 아님 (연결이 중단 되기 때문에)
# middleware는 왼쪽에서 -----> 오른쪽 순서로 작동함 next()를 실행하면 다음게 실행 됨 ex) app.get("/", logger, handleHome);

# "dependencies" 는 프로젝트에 필요한 것 ex)자동차 연료
# "devDependencies"는 개발자가 개발하는데 필요한 것 ex)자동차 네비게이션

# 서버는 컴퓨터 전체를 listen할 수 없다 그래서 port가 있어야 함 port는 예를들어 컴퓨터의 창문이나 문 같은 거임
# port 4000번을 쓰는 이유는 대부분 비어있기 때문에
# request 를 전달하려면 url을 사용해야 한다.
# 어떤 웹사이트를 가려면 내가 가는게 아니라 웹사이트가 오게 하는 것. 내가 요청을 하면 서버가 나의 브라우저를 보내주는 것.
# *브라우저는 서버에게 페이지를 request하는 거임. arrow function은 return이 내포되어 있음.

# routes를 만들고 controllers를 만든다
# 중요한건 위치임(requset, response) 이름은 상관없음 첫 번째 arguments는 X, 두 번째는 Y여도 상관 x
# controller가 있어야 할 자리에 함수를 넣어주지 않으면 에러가 생김!!**

# 라우터는 컨트롤러와 URL의 관리를 쉽게해준다
# 라우터는 너희가 작업중인 주제를 기반으로 URL을 그룹화해줌
# (clean code) 일단 코드를 작성한다 얼마나 지저분한지는 상관이없다 그 다음에 코드를 정리해라 코드를 작성한 시간만큼, 코드를 정리하는데 시간을 들여야 한다.
# 자바스크립트에서는 모든 파일이 자기만의 세계를 가진다 (새로운 파일마다 express import 해줘야한다)
# 모든 파일은 모듈이고, 거품과도 같다 프로젝트에 있는 모든 파일은 분리된 모듈이다 그래서 무언가를 바깥에 공유하기 위해서는 익스포트(export)를 먼저 해줘야함
# 먼저 export 하고 import 해야함
# import (express) from "express"; express 이름이 달라도 된다 하지만 대부분 헷갈려서 같은 이름을 유지함

# globalRouter는 controller가 필요가 없다 다만 url을 깔끔하게 하기위해 쓰는것일 뿐 다른 이유는 없음
# 파일은 한가지 default export 밖에 가질 수 없다 그렇기 때문에 이름이 달라도 가능했음 But export const 를 하면 실제 변수명이 같아야함
# 자바스크립트에선 변수명으로 사용 불가하는게 몇가지 있음 ex)new, delete..
# 라우터는 url이 어떻게 시작하는지에 따라 나누는 방법이다 url을 그룹화하는 방법임 **라우터는 공통 시작부분을 기반으로 url을 정리해주는 방법이다
# ****우리는 변수를 다른 파일에서 가져와 무언가를 임포트하기 전에는 익스포트를 해야한다.**** export default를 쓰면 한가지 밖에 공유가 불가능하다. 
# 그래서 각각의 함수에 export를 달아줘야 함 이렇게 하면 하나 이상을 공유할 수 있음 그리고 쓰는 법이 약간 다름 import {"same name"} form "/경로" 괄호안에는 같은 이름을 써야 함
# 같은 이름을 쓰지 않으면 node.js는 길을 잃음

# ("/:주소") :을 표시하는 이유는 express한테 이게 변수라는 것을 알려주기 위해서임
# express는 이 url이 변수를 가지고 있다는걸 이해함 그리고 express는 우리가 고른 이름과 함께 값을 제공해줌
# 리퀘스느 오브젝트는 리퀘스트에 대한 정보를 담고 있음
# :가 꼭 필요함 없으면 그냥 텍스트임 express는 순서대로 체크하고, upload가 있으면 거기로 데려가 줌
# 정규식: 문자열로부터 특정 정보를 추출해내는 방법

####### 5 ######
# 5.0) node.js 안에 HTML을 다 쓰기에는 너무 길다 말이 안됨 시간아끼기 위해서 pug를 써야함

# 5.1) 1.pug를 설지한다 
#      2.view engine을 pug로 설정해야 한다 app.set("view engine", "pug");
#      3.실제로 pug 파일을 생성한다
# pug를 보내는 과정 pug가 home.pug 파일을 렌더링해서 평범한 html로 변환해줌
# home.pug 파일을 그대로 유저에게 보내는게 아님
# home.pug를 우선 pug에게 보내고 pug가 랜더링해서 평범한 html로 변환해줌
# 그래서 유저는 home.pug를 보는일이 없고 우리가 pug로 파일을 보내면, pug가 이 평범한 html로 변환해줌
# 기본적으로 express는 cwd + /views에서 pug 파일을 찾는다
# cwd 루트 파일은 서버를 기동하는 파일의 위치에 따라 결정된다
# doucuments/wetube 폴더에서 package.json이 node.js를 실행하고 있음 우리가 wetube 안에 있는 package.json에서 node.js를 실행하고 있기 때문에 이 디렉토리가 현재 작업 디렉토리가 되는거임
# 현재 작업 디렉토리는 node.js를 실행하는 디렉토리임

# 5.2) default 값을 process.cwd() + "/src/views" (현재 작업 디렉토리 + "/views/src"로 바꿔야함
# pug의 최고 장점은 반복할 필요가 없다
# 첫째로 파일명은 띄어쓰기가 있으면 안됨 둘째 대문자가 있어도 안됨
# 자바스크립트 코드는 유저가 보기전에 평범한 텍스트로 변환 됨 이것이 바로 렌더링
# partials 최고의 강점 include 파일 경로 해주면 반복작업 필요없음

# 5.3) 블록이란 템플릿의 창문같은 것 무언가를 집어 넣을 수 있는 곳
# extends(확장), inheritance(상속)은 대단함

# 5.4) extend는 html의 베이스를 가질 수 있게 해주기 때문에 좋다
# 블록은 확장한 템플릿 안에 내용을 넣을 수 있는 창문 또는 문 같은것
# 블록 이름은 항상 같아야 함
# 우리는 home.pug를 렌더링하는데 base.pug를 확장하고 base.pug는 우리가 직접 채우는 content 블록을 가지고 있고 그리고 base.pug는 pageTitle을 가지고 있다 그게 우리가 제공해야하는 변수임
# 변수를 제공하는 방법은 render에 파일명을 쓰고 변수를 쓰는거다 컨트롤러에서 변수를 제공

# 5.5) pug는 지저분한 html을 쓰지 않고, 파이썬처럼 깔끔한 코드를 쓸 수 있다.
# pug는 띄어쓰기 탭으로 구분이 가능하다
# block은 확장한 파일과 커뮤니케이션 할 수 있게 해준다

# 5.6) MVP.css 는 html태그들을 살짝 꾸며주는 역할 (https://andybrewer.github.io/mvp/) 사이트 임시방편으로 사용 css는 나중에 하기 때문에

# 5.7) h1 pageTitle을 쓰면 그냥 text인데 h1=pageTitle을 쓰면 variable로 넘어가게 된다 variable이랑 뒤에 text랑 같이쓰려면 ex) ${pageTitle} aa
# condition if, if else 비슷한 문장임

# 5.8) Iteration은 기본적으로 elements의 list를 보여주는 거임
# list를 보여주려면 첫째로, template에는 array인 variable이 있어야 함 array가 없으면 동작하지 않음
# controller에서의 이름이랑 다른 pugpage랑 변수명이 같아야 한다
# Pug는 자동적으로 videos 안에 뭐가 있는지 없는지 체크한다
# 굳이 array이어야만 할 필요는 없고, array이거나 객체도 가능 each else

# 5.9) mixin이란, partials와 같은 것 데이터를 받을 수 있는 일종의 미리 만들어진 HTML block이라고 볼 수 있다
# mixin은 똑똑한 partials이다

# 5.10) Iteration은 array의 모든 element에 대해 특정 행동을 취할 때 사용함
# each X in Y에서 Y는 반드시 존재해야 한다
# each in else 같은 문법은 javascript에 없다 pug에만 있는 문법임
# pug는 똑똑해서 Y가 빈 array 이거나 length가 0이면 바로 알아차려서 else를 보여준다
# mixin은, 이미 만들어진 HTML 조각과 같은데 바깥 세계로부터 정보를 가져오는 역할을 한다.
# mixin을 사용하고 싶다면 +를 붙여햐 함

####### 6 ######
# 6.0) #{} 이 기호를 쓰는 방식은 attribute에는 사용할 수 없다 href, calss나 id 같은 것들에 가능하지 않음
# 그래서 + 하기 방식이나 ``백틱을 사용해야 한다.

# 6.1) absoulte 와 relative url의 차이점 만약 href의 앞부분에 /를 넣으면 어디에 있든 상관없이 root 경로 + /edit으로 가게 된다.
# 근데 /을 지우면? 이건 relative url이 된다

# 6.2)

# 6.3) 만약 get method를 사용하면, 그 form에 있는 정보가 url에 들어가기 된다
# 너의 database를 변경할 data로 뭔가를 하는가? 뭔가를 수정하거나 추거하거나 삭제하거나 하는 경우 post를 써야한다
# 만약 그냥 데이터를 받는 게 목적이라면, get을 사용하면 된다.
# POST 도 GET 이랑 구조가 같다 URL이 있고 function이 있다
# videoRouter.route("/:id(\\d+)/edit").get(getEdit).post(postEdit); 하나는 get request를 위한 것 하나는 post request를 위한 것 줄여 쓸 수 있다.
# req.params는 우리에게 주어지는 정보
# routes를 사용하기 전에 이 middleware를 사용해야 한다 middleware가 그 form을 이해하고, 그것들은 자바스크립트로 변형시켜줘서 우리가 사용할 수 있게 만드는 것.
# 그걸 위해서 middleware를 route를 사용하기 전에 사용해야 한다.
# app.use(express.urlencoded({ extended: true })); express application이 form의 value들을 이해할 수 있도록 하고 멋진 자바스크립트 형식으로 변형시킨다.

# 6.4) get과 post를 따로 쓰는 대신에, 하나의 경로만 필요로 하는 route를 사용함 그러면 get request와 post request 둘 다 다뤄줌
# 보통 2개 이상의 method를 사용하는 게 아니면, route는 사용하지 않음
# req.body 는 form에 있는 value의 javascript representation이다.
# 그치만 이건 우리가 아주 훌륭한 middleware를 설정해야만 가능한 일이다.
# 바로 urlencoded가 HTML form을 이해하고 그 form을 우리가 사용할 수 있는 javascript object 형식으로 통역해준다.
# middleware가 videoRouter 전에 오기 때문에 어떤 request가 videoRouter.post에 이르렀을 때, req.body가 이미 준비되어 있음. (중요)
# form을 javascript으로 바꿔주는 midleware가 route 전에 있기 때문이다 그 postEdit을 가지고 있는 videoRouter 전에 있다..코드는 위에서 부터 아래로 읽기 때문에
# input 안에 name 넣는 걸 까먹으면 req.body에서 데이터를 볼 수 없다
# mongoose를 통해서, 자바스크립트에서 mongodb와 상호작용을 할거다

# 6.5) 정리
# 우선 controller를 만든 다음에 router를 만들어준다

# 6.6) 버튼을 눌렀을 때 홈페이지를 render한게 아니라 url만 바꾼것임
# input에서 data를 얻을 수 있는 방법은? req.body에서 유저가 input에 작성한 data를 얻을 수 있다.
# 모든 input은 이름이 있어야 한다!

# 6.7) mongodb가 훌륭한 이유는 document-based(문서 기반) 이라는 점이다 일반적으로, database는 document-based가 아니다 보통 sql-based이다 행 기반 엑셀같은
# database도 object로 생각한다 (mongodb)에 저장한 것들은 JSON-like-document임. 그러므로 행으로 된 데이터를 저장할 필요가 없다
# 윈도우는 chocolaty.org 를 사용해서 다운받는게 편하다